from core.attack import __go_for_attacks as attack
from core.config import _core_config
from core.load_modules import load_all_modules
import nmap3, socket, shlex, json, re, sys

# Regular expression for catching open ports
regex = '[0-9]*\/(?:tcp|udp)\s*open.\s'

# Regular expression for catching every detailed vulnerability description
regex2 = '(?:\|\s*\[[0-9]*\]|\|\s*\[CVE\-.*?\]).*?Matches.*?http.*?\n'

# Regular expression for  catching match score
regex3 = 'Matches:\s*(\S)'

# Global  indicator for  whether there is vulnerability  found
test_has_vulnerability = False

# default config
default_config = _core_config()


# This function parse a string into  json
def parse_to_json(s, target) -> 'Indicator 1,0 or -1':
    """Takes as input Vulscan output string, and a target IP address"""
    my_dict = {}
    my_dict['target'] = target
    l1 = re.findall(regex, s)
    if not l1:
        print('Error finding all lines that match the regular expression pattern!')
        print('Either there are no open ports discovered or regex find  failed')
        return None
    l2 = re.split(regex, s)
    if not l2:
        print('Error splitting the string according to regex!')
        print('Either there are no open ports discovered or regex failed to split')
        return None

    l2.pop(0)  # Remove the first  element, which is  the nmap default header
    outer_dict = {}
    for service, description in zip(l1, l2):
        outer_dict[service.split()[0]] = inner_dict_create(service, description)

    my_dict['open_ports'] = outer_dict

    if test_has_vulnerability:
        try:
            json.dump(my_dict, open(my_dict['target'] + '.json', 'w'))
            return 1
        except Exception  as e:
            print(e)
            return -1
    else:
        return 0


# This function creates the inner-most dictionary key='service','description'
def inner_dict_create(service, description) -> 'dict':
    tmp = description.split('\n', maxsplit=1)
    tmp_dict = {'service': tmp[0], 'description': filter_false_positive(tmp[1])}

    return tmp_dict


# This function filters out false-positive matches <4
def filter_false_positive(s) -> 'str or None':
    tmp = re.findall(regex2, s, re.DOTALL)
    tmp1 = []
    if tmp:
        for vulns in tmp:
            match = re.search(regex3, vulns)
            if match:
                if int(match.group(1)) >= 4:
                    tmp1.append(vulns)
        if tmp1:
            global test_has_vulnerability
            test_has_vulnerability = True
            return '\n'.join(tmp1)
    


# this  function determines the host(running the script) ip address
def determine_host_ip():
    soc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        soc.connect(('8.8.8.8', 1))
        ip = soc.getsockname()[0]
        soc.close()
        return ip

    except:  # no internet connection
        print('time out!')
        soc.close()
        return False


# This discovers all live hosts  within a LAN
def host_discovery(ip):
    if ip.startswith('192') or ip.startswith('10'):
        nmap = nmap3.NmapHostDiscovery()
        result = nmap.nmap_no_portscan(ip + '/24')
    else:
        return None

    return [h['addr'] for h in result['hosts']]


# This  scanner object takes as input an IP or a list of IPs to scan
# If no IP given, it  tries to detects live hosts and scan them all
class Vulnerability_Scanner():

    def __init__(self, target=None, log_path='./predefined_vuln_scan_result.json'):
        for key, value in default_config.items():
            setattr(self, key, value)
        self.backup_ports = self.ports
        self.scan_method = load_all_modules()
        self.scan_method.remove('all')
        self.log_in_file = log_path
        self.vuln_ip = set()
        if target is None:
            ip = determine_host_ip()
            if ip:
                self.targets = host_discovery(ip)
            else:
                print('Host IP address detection failed, check internet connection')
                print('try manually enter the IP address of the machine running this test')


        else:
            if isinstance(target, list):
                self.targets = target
            else:
                self.targets = [target]
        self.verbose_level = 0

    def type1_scan(self):  # this scans for a pre-defined  set of vulnerabilities
        if attack(self.targets, self.check_ranges, self.check_subdomains, self.log_in_file, self.time_sleep,
                  self.language, self.verbose_level,
                  self.retries,
                  self.socks_proxy, self.users, self.passwds, self.timeout_sec, self.thread_number, self.ports,
                  self.ping_flag, self.methods_args,
                  self.backup_ports, self.scan_method, self.thread_number_host, self.graph_flag, self.profile, False):
            print('Type 1 scan results save in the log file {}'.format(self.log_in_file))
            data = json.load(open(self.log_in_file))
            for item in data:
                if 'vuln' in item['DESCRIPTION'].lower() or 'found' in item['DESCRIPTION'].lower()\
                        or 'success' in item['DESCRIPTION'].lower():
                    return True
                else:
                    return False


    def type2_scan(self):  # This  uses nmap to determin service first,then  lookup cve locally
        nmap = nmap3.NmapScanTechniques()
        indicator = set()
        for target in self.targets:
            print('Running tests  against :' + target)
            print('Please wait........')
            cmd = 'nmap --script=vulscan/vulscan.nse --script-args vulscanoutput=details -sV ' + target
            result = nmap.run_command(shlex.split(cmd))
            x = parse_to_json(result, target)
            indicator.add(x)
            if x == 1:
                print('Vulnerability found for {}, saved in report {}.json  file'.format(target, target))
                print()
                self.vuln_ip.add(target)
            elif x == -1:
                print('An error occurred while handling json  files for {}'.format(target))
                print()


            else:
                print('There is no vulnerability discovered for {}'.format(target))
                print()

        return 1 in indicator
